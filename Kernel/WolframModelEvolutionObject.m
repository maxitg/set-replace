(* ::Package:: *)

(* ::Title:: *)
(*WolframModelEvolutionObject*)


(* ::Text:: *)
(*This is an object that is returned by WolframModel. It allows one to query the set at different generations and different steps.*)


Package["SetReplace`"]


PackageExport["WolframModelEvolutionObject"]


PackageScope["propertyEvaluate"]


PackageScope["$propertiesParameterless"]
PackageScope["$newParameterlessProperties"]


(* ::Text:: *)
(*Keys in the data association.*)


PackageScope["$version"]
PackageScope["$rules"]
PackageScope["$maxCompleteGeneration"]
PackageScope["$terminationReason"]
PackageScope["$atomLists"]
PackageScope["$eventRuleIDs"]
PackageScope["$eventInputs"]
PackageScope["$eventOutputs"]
PackageScope["$eventGenerations"]
PackageScope["$creatorEvents"]
PackageScope["$destroyerEvents"]
PackageScope["$generations"]


$version = "Version";
$rules = "Rules";
$maxCompleteGeneration = "MaxCompleteGeneration";
$terminationReason = "TerminationReason";
$atomLists = "AtomLists";
$eventRuleIDs = "EventRuleIDs";
$eventInputs = "EventInputs";
$eventOutputs = "EventOutputs";
$eventGenerations = "EventGenerations";

(* Old keys *)
$creatorEvents = "CreatorEvents";
$destroyerEvents = "DestroyerEvents";
$generations = "Generations";


(* ::Section:: *)
(*Documentation*)


WolframModelEvolutionObject::usage = usageString[
	"WolframModelEvolutionObject[`...`] is an evolution object generated by ",
	"WolframModel.",
	"\n",
	"WolframModelEvolutionObject[`...`][`g`] yields the set at generation `g`.",
	"\n",
	"WolframModelEvolutionObject[`...`][\"StateAfterEvent\", `s`] yields the state ",
	"after `s` substitution events.",
	"\n",
	"WolframModelEvolutionObject[`...`][\"Properties\"] yields the list of all ",
	"available properties."];


(* ::Section:: *)
(*SyntaxInformation*)


SyntaxInformation[WolframModelEvolutionObject] = {"ArgumentsPattern" -> {___}};


(* ::Section:: *)
(*Boxes*)


WolframModelEvolutionObject /:
		MakeBoxes[
			evo : WolframModelEvolutionObject[data_ ? evolutionDataQ],
			format_] := Module[
	{generationsCount, maxCompleteGeneration, eventsCount, terminationReason, rules, initialSet},
	generationsCount = evo["TotalGenerationsCount"];
	maxCompleteGeneration = Replace[evo["CompleteGenerationsCount"], _ ? MissingQ -> "?"];
	generationsDisplay = If[generationsCount === maxCompleteGeneration,
		generationsCount,
		Row[{maxCompleteGeneration, "\[Ellipsis]", generationsCount}]];
	eventsCount = evo["AllEventsCount"];
	terminationReason = evo["TerminationReason"];
	rules = evo["Rules"];
	initialSet = evo[0];
	BoxForm`ArrangeSummaryBox[
		WolframModelEvolutionObject,
		evo,
		style[$lightTheme][$evolutionObjectIcon],
		(* Always grid *)
		{{BoxForm`SummaryItem[{"Generations: ", generationsDisplay}]},
		{BoxForm`SummaryItem[{"Events: ", eventsCount}]}},
		(* Sometimes grid *)
		{If[MissingQ[terminationReason], Nothing, {BoxForm`SummaryItem[{"Termination reason: ", terminationReason}]}],
		{BoxForm`SummaryItem[{"Rules: ", Short[rules]}]},
		{BoxForm`SummaryItem[{"Initial set: ", Short[initialSet]}]}},
		format,
		"Interpretable" -> Automatic
	]
]


(* ::Section:: *)
(*Implementation*)


$accessorProperties = <|
	"Version" -> $version,
	"Rules" -> $rules,
	"CompleteGenerationsCount" -> $maxCompleteGeneration,
	"AllEventsEdgesList" -> $atomLists
|>;


$propertyArgumentCounts = Join[
	<|
		"EvolutionObject" -> {0, 0},
		"FinalState" -> {0, 0},
		"FinalStatePlot" -> {0, Infinity},
		"StatesList" -> {0, 0},
		"StatesPlotsList" -> {0, Infinity},
		"EventsStatesPlotsList" -> {0, Infinity},
		"AllEventsStatesEdgeIndicesList" -> {0, 0},
		"AllEventsStatesList" -> {0, 0},
		"Generation" -> {1, 1},
		"StateEdgeIndicesAfterEvent" -> {1, 1},
		"StateAfterEvent" -> {1, 1},
		"TotalGenerationsCount" -> {0, 0},
		"PartialGenerationsCount" -> {0, 0},
		"GenerationsCount" -> {0, 0},
		"GenerationComplete" -> {0, 1},
		"AllEventsCount" -> {0, 0},
		"GenerationEventsCountList" -> {0, 0},
		"GenerationEventsList" -> {0, 0},
		"FinalDistinctElementsCount" -> {0, 0},
		"AllEventsDistinctElementsCount" -> {0, 0},
		"VertexCountList" -> {0, 0},
		"EdgeCountList" -> {0, 0},
		"FinalEdgeCount" -> {0, 0},
		"AllEventsEdgesCount" -> {0, 0},
		"AllEventsGenerationsList" -> {0, 0},
		"CausalGraph" -> {0, Infinity},
		"LayeredCausalGraph" -> {0, Infinity},
		"TerminationReason" -> {0, 0},
		"AllEventsRuleIndices" -> {0, 0},
		"AllEventsList" -> {0, 0},
		"EventsStatesList" -> {0, 0},
		"EdgeCreatorEventIndices" -> {0, 0},
		"EdgeDestroyerEventsIndices" -> {0, 0},
		"EdgeDestroyerEventIndices" -> {0, 0},
		"EdgeGenerationsList" -> {0, 0},
		"Properties" -> {0, 0}|>,
	Association[# -> {0, 0} & /@ Keys[$accessorProperties]]];


(*This are here for compatibility with old code.*)
$oldToNewPropertyNames = <|
	"UpdatedStatesList" -> "AllEventsStatesList",
	"AllExpressions" -> "AllEventsEdgesList",
	"CreatorEvents" -> "EdgeCreatorEventIndices",
	"DestroyerEvents" -> "EdgeDestroyerEventIndices",
	"MaxCompleteGeneration" -> "CompleteGenerationsCount",
	"EventGenerations" -> "AllEventsGenerationsList",
	"EventGenerationsList" -> "AllEventsGenerationsList",
	"ExpressionGenerations" -> "EdgeGenerationsList",
	"EventsCount" -> "AllEventsCount",
	"EventsList" -> "AllEventsList",
	"AtomsCountFinal" -> "FinalDistinctElementsCount",
	"AtomsCountTotal" -> "AllEventsDistinctElementsCount",
	"ExpressionsCountFinal" -> "FinalEdgeCount",
	"ExpressionsCountTotal" -> "AllEventsEdgesCount",
	"SetAfterEvent" -> "StateAfterEvent"
|>;


$propertiesParameterless = Join[
  Keys @ Select[#[[1]] == 0 &] @ $propertyArgumentCounts,
  Select[First[$propertyArgumentCounts[$oldToNewPropertyNames[#]]] == 0 &] @ Keys[$oldToNewPropertyNames]
];


$newParameterlessProperties = Intersection[$propertiesParameterless, Keys[$propertyArgumentCounts]];


(* ::Subsection:: *)
(*Argument checks*)


(* ::Subsection:: *)
(*Master options handling*)


General::missingMaxCompleteGeneration = "Cannot drop incomplete generations in an object with missing information.";


propertyEvaluate[False, boundary_][evolution_, caller_, rest___] := If[MissingQ[evolution["CompleteGenerationsCount"]],
	Message[caller::missingMaxCompleteGeneration],
	propertyEvaluate[True, boundary][deleteIncompleteGenerations[evolution], caller, rest]
]


propertyEvaluate[False, boundary_][evolution_, caller_, rest___] :=
	propertyEvaluate[True, boundary][deleteIncompleteGenerations[evolution], caller, rest]


propertyEvaluate[includePartialGenerations : Except[True | False], _][evolution_, caller_, ___] := (
	Message[caller::invalidFiniteOption, "IncludePartialGenerations", includePartialGenerations, {True, False}];
	Throw[$Failed]
)


includeBoundaryEventsPattern = None | "Initial" | "Final" | All;


propertyEvaluate[_, boundary : Except[includeBoundaryEventsPattern]][evolution_, caller_, ___] := (
	Message[caller::invalidFiniteOption, "IncludeBoundaryEvents", boundary, {None, "Initial", "Final", All}];
	Throw[$Failed]
)


deleteIncompleteGenerations[WolframModelEvolutionObject[data_]] := Module[{
		maxCompleteGeneration, eventIndicesToKeep, newEventOutputs, expressionIndicesToKeep,
		oldToNewExpressionIndices},
	maxCompleteGeneration = data[$maxCompleteGeneration];
	eventIndicesToKeep = Position[data[$eventGenerations], _ ? (# <= maxCompleteGeneration &)][[All, 1]];
	newEventOutputs = data[$eventOutputs][[eventIndicesToKeep]];
	expressionIndicesToKeep = Union[Catenate[newEventOutputs]];
	oldToNewExpressionIndices = Thread[expressionIndicesToKeep -> Range[Length[expressionIndicesToKeep]]];
	WolframModelEvolutionObject[<|$version -> data[$version],
		$rules -> data[$rules],
		$maxCompleteGeneration -> data[$maxCompleteGeneration],
		$terminationReason -> data[$terminationReason],
		$atomLists -> data[$atomLists][[expressionIndicesToKeep]],
		$eventRuleIDs -> data[$eventRuleIDs][[eventIndicesToKeep]],
		$eventInputs -> data[$eventInputs][[eventIndicesToKeep]],
		$eventOutputs -> newEventOutputs,
		$eventGenerations -> data[$eventGenerations][[eventIndicesToKeep]]|>]
]


(* ::Subsubsection:: *)
(*Unknown property*)


propertyEvaluate[masterOptions___][
		obj_WolframModelEvolutionObject, caller_, property : Alternatives @@ Keys[$oldToNewPropertyNames], args___] :=
	propertyEvaluate[masterOptions][obj, caller, $oldToNewPropertyNames[property], args]


propertyEvaluate[___][
		WolframModelEvolutionObject[data_ ? evolutionDataQ],
		caller_,
		s : Except[_Integer],
		___] /; !MemberQ[Keys[$propertyArgumentCounts], s] := (
	makeMessage[caller, "unknownProperty", s];
	Throw[$Failed]
)


(* ::Subsubsection:: *)
(*Property argument counts*)


makePargxMessage[property_, caller_, givenArgs_, expectedArgs_] := makeMessage[
	caller,
	"pargx",
	property,
	givenArgs,
	If[givenArgs == 1, "", "s"],
	If[expectedArgs[[1]] != expectedArgs[[2]], "between ", ""],
	expectedArgs[[1]],
	If[expectedArgs[[1]] != expectedArgs[[2]], " and ", ""],
	If[expectedArgs[[1]] != expectedArgs[[2]], expectedArgs[[2]], ""],
	If[expectedArgs[[1]] != expectedArgs[[2]] || expectedArgs[[1]] != 1, "s", ""],
	If[expectedArgs[[1]] != expectedArgs[[2]] || expectedArgs[[1]] != 1, "are", "is"]
]


propertyEvaluate[___][
		WolframModelEvolutionObject[data_ ? evolutionDataQ],
		caller_,
		s_String,
		args___] /;
			With[{argumentsCountRange = $propertyArgumentCounts[s]},
				Not[MissingQ[argumentsCountRange]] &&
				Not[argumentsCountRange[[1]] <= Length[{args}] <= argumentsCountRange[[2]]]] := (
	makePargxMessage[s, caller, Length[{args}], $propertyArgumentCounts[s]];
	Throw[$Failed]
)


(* ::Subsubsection:: *)
(*Correct options*)


$newCausalGraphOptions = {Background -> Automatic, VertexStyle -> Automatic, EdgeStyle -> Automatic};
$causalGraphOptions = Join[FilterRules[Options[Graph], Except[$newCausalGraphOptions]], $newCausalGraphOptions];

$newLayeredCausalGraphOptions = {GraphLayout -> Automatic};
$layeredCausalGraphOptions =
	Join[FilterRules[$causalGraphOptions, Except[$newLayeredCausalGraphOptions]], $newLayeredCausalGraphOptions];

$propertyOptions = <|
	"CausalGraph" -> $causalGraphOptions,
	"LayeredCausalGraph" -> $layeredCausalGraphOptions,
	"StatesPlotsList" -> Options[WolframModelPlot],
	"EventsStatesPlotsList" -> Options[WolframModelPlot],
	"FinalStatePlot" -> Options[WolframModelPlot]
|>;


propertyEvaluate[True, includeBoundaryEventsPattern][
		obj : WolframModelEvolutionObject[_ ? evolutionDataQ],
		caller_,
		property : Alternatives @@ Keys[$propertyOptions],
		o : OptionsPattern[]] := (
	Message[
		caller::optx,
		First[Last[Complement[{o}, FilterRules[{o}, Options[$propertyOptions[property]]]]]],
		Defer[obj[property, o]]];
	Throw[$Failed]
)


propertyEvaluate[True, includeBoundaryEventsPattern][
		WolframModelEvolutionObject[_ ? evolutionDataQ],
		caller_,
		property : Alternatives @@ Keys[$propertyOptions],
		o___] := (
	makeMessage[caller, "nonopt", property, Last[{o}]];
	Throw[$Failed]
)


(* ::Subsection:: *)
(*Properties*)


propertyEvaluate[___][
		WolframModelEvolutionObject[data_ ? evolutionDataQ], caller_, "Properties"] :=
	Keys[$propertyArgumentCounts]


(* ::Subsection:: *)
(*EvolutionObject*)


propertyEvaluate[True, includeBoundaryEventsPattern][
		WolframModelEvolutionObject[data_ ? evolutionDataQ],
		caller_,
		"EvolutionObject"] := WolframModelEvolutionObject[data]


(* ::Subsection:: *)
(*Rules*)


propertyEvaluate[___][
		WolframModelEvolutionObject[data_ ? evolutionDataQ], caller_, "Rules"] :=
	data[$rules]


(* ::Subsection:: *)
(*TotalGenerationsCount*)


propertyEvaluate[True, includeBoundaryEventsPattern][
		WolframModelEvolutionObject[data_ ? evolutionDataQ],
		caller_,
		"TotalGenerationsCount"] := Max[data[$eventGenerations]]


(* ::Subsection:: *)
(*PartialGenerationsCount*)


propertyEvaluate[True, includeBoundaryEventsPattern][
		obj : WolframModelEvolutionObject[_ ? evolutionDataQ],
		caller_,
		"PartialGenerationsCount"] :=
	If[MissingQ[obj["CompleteGenerationsCount"]],
		obj["CompleteGenerationsCount"],
		obj["TotalGenerationsCount"] - obj["CompleteGenerationsCount"]]


(* ::Subsection:: *)
(*GenerationsCount*)


propertyEvaluate[True, includeBoundaryEventsPattern][
		obj : WolframModelEvolutionObject[_ ? evolutionDataQ],
		caller_,
		"GenerationsCount"] := obj /@ {"CompleteGenerationsCount", "PartialGenerationsCount"}


(* ::Subsection:: *)
(*GenerationComplete*)


propertyEvaluate[True, includeBoundaryEventsPattern][
		obj : WolframModelEvolutionObject[_ ? evolutionDataQ],
		caller_,
		"GenerationComplete",
		generation_Integer] /; generation >= 0 := generation <= obj["CompleteGenerationsCount"]


propertyEvaluate[True, includeBoundaryEventsPattern][
		obj : WolframModelEvolutionObject[_ ? evolutionDataQ],
		caller_,
		"GenerationComplete",
		generation_ : -1] :=
	toPositiveStep[
			propertyEvaluate[True, None][obj, caller, "TotalGenerationsCount"], generation, caller, "Generation"] <=
		obj["CompleteGenerationsCount"]


(* ::Subsection:: *)
(*AllEventsCount*)


propertyEvaluate[True, includeBoundaryEvents : includeBoundaryEventsPattern][
		WolframModelEvolutionObject[data_ ? evolutionDataQ], caller_, "AllEventsCount"] :=
	Length[data[$eventRuleIDs]] + Switch[includeBoundaryEvents, None, -1, "Initial" | "Final", 0, All, 1]


(* ::Subsection:: *)
(*GenerationEventsCountList*)


propertyEvaluate[True, includeBoundaryEvents : includeBoundaryEventsPattern][
		obj : WolframModelEvolutionObject[_ ? evolutionDataQ], caller_, "GenerationEventsCountList"] :=
	Length /@ Split[propertyEvaluate[True, includeBoundaryEvents][obj, caller, "AllEventsGenerationsList"]]


(* ::Subsection:: *)
(*GenerationEventsList*)


propertyEvaluate[True, includeBoundaryEvents : includeBoundaryEventsPattern][
		obj : WolframModelEvolutionObject[_ ? evolutionDataQ], caller_, "GenerationEventsList"] :=
	TakeList[
		propertyEvaluate[True, includeBoundaryEvents][obj, caller, "AllEventsList"],
		propertyEvaluate[True, includeBoundaryEvents][obj, caller, "GenerationEventsCountList"]]


(* ::Subsection:: *)
(*Direct Accessors*)


propertyEvaluate[True, includeBoundaryEventsPattern][
		WolframModelEvolutionObject[data_ ? evolutionDataQ],
		caller_,
		property_ ? (MemberQ[Keys[$accessorProperties], #] &)] :=
	Lookup[data, $accessorProperties[property], Missing["NotAvailable"]];


(* ::Subsecion:: *)
(*StateEdgeIndicesAfterEvent*)


(* ::Subsubsection:: *)
(*Convert to positive generation number*)


toPositiveStep[total_, requested_Integer, caller_, name_] /; 0 <= requested <= total := requested


toPositiveStep[total_, requested_Integer, caller_, name_] /; - total - 1 <= requested < 0 := 1 + total + requested


toPositiveStep[total_, requested_Integer, caller_, name_] /; !(- total - 1 <= requested <= total) := (
	makeMessage[caller, "stepTooLarge", name, requested, total];
	Throw[$Failed]
)


toPositiveStep[total_, requested : Except[_Integer], caller_, name_] := (
	makeMessage[caller, "stepNotInteger", name, requested];
	Throw[$Failed]
)


(* ::Subsection:: *)
(*StateEdgeIndicesAfterEvents*)


stateEdgeIndicesAfterEvents[WolframModelEvolutionObject[data_], caller_, events_] := Module[{createdExpressions, destroyedExpressions, edgeCounts},
	createdExpressions = Catenate[data[$eventOutputs][[events + 1]]];
	destroyedExpressions = Catenate[data[$eventInputs][[events + 1]]];
	If[DuplicateFreeQ[destroyedExpressions],
		Sort[Complement[createdExpressions, destroyedExpressions]],
	(* else *)
		makeMessage[caller, "multiwayState", Last[Keys[Sort[Counts[destroyedExpressions]]]]];
		Throw[$Failed]
	]
]


(* ::Subsubsection:: *)
(*Implementation*)


propertyEvaluate[True, includeBoundaryEventsPattern][
			obj : WolframModelEvolutionObject[data_ ? evolutionDataQ],
			caller_,
			"StateEdgeIndicesAfterEvent",
			s_] := Module[{
		positiveEvent = toPositiveStep[propertyEvaluate[True, None][obj, caller, "AllEventsCount"], s, caller, "Event"],
		edgeCounts},
	stateEdgeIndicesAfterEvents[obj, caller, Range[0, positiveEvent]]
]


(* ::Subsection:: *)
(*StateAfterEvent*)


propertyEvaluate[True, boundary : includeBoundaryEventsPattern][
			obj : WolframModelEvolutionObject[data_ ? evolutionDataQ],
			caller_,
			"StateAfterEvent",
			s_] := data[$atomLists][[propertyEvaluate[True, boundary][obj, caller, "StateEdgeIndicesAfterEvent", s]]]


(* ::Subsection:: *)
(*FinalState*)


propertyEvaluate[True, boundary: includeBoundaryEventsPattern][
		obj : WolframModelEvolutionObject[data_ ? evolutionDataQ],
		caller_,
		"FinalState"] := propertyEvaluate[True, boundary][obj, caller, "StateAfterEvent", -1]


(* ::Subsection:: *)
(*FinalStatePlot*)


General::nonHypergraphPlot = "`1` is only supported for states that are hypergraphs.";


propertyEvaluate[True, boundary : includeBoundaryEventsPattern][
		obj : WolframModelEvolutionObject[_ ? evolutionDataQ],
		caller_,
		property : "FinalStatePlot",
		o : OptionsPattern[] /; (Complement[{o}, FilterRules[{o}, Options[WolframModelPlot]]] == {})] :=
	Check[
		Quiet[
			Check[
				WolframModelPlot[propertyEvaluate[True, boundary][obj, caller, "FinalState"], o],
				Message[caller::nonHypergraphPlot, property],
				WolframModelPlot::invalidEdges],
			WolframModelPlot::invalidEdges],
		Throw[$Failed]]


(* ::Subsection:: *)
(*AllEventsStatesEdgeIndicesList & AllEventsStatesList*)


propertyEvaluate[True, boundary : includeBoundaryEventsPattern][
		evolution : WolframModelEvolutionObject[data_ ? evolutionDataQ],
		caller_,
		property : "AllEventsStatesList" | "AllEventsStatesEdgeIndicesList"] :=
	propertyEvaluate[True, boundary][
			evolution,
			caller,
			Replace[
				property,
				{"AllEventsStatesList" -> "StateAfterEvent", "AllEventsStatesEdgeIndicesList" -> "StateEdgeIndicesAfterEvent"}],
			#] & /@
		Range[0, propertyEvaluate[True, None][WolframModelEvolutionObject[data], caller, "AllEventsCount"]]


(* ::Subsection:: *)
(*Generation*)


(* ::Text:: *)
(*Note that depending on how evaluation was done (i.e., the order of substitutions), it is possible that some expressions of a requested generation were not yet produced, and thus expressions for the previous generation would be used instead. That, however, should never happen if the evolution object is produced with WolframModel.*)


(* ::Subsubsection:: *)
(*Positive generations*)


propertyEvaluate[True, includeBoundaryEventsPattern][
			obj : WolframModelEvolutionObject[data_ ? evolutionDataQ],
			caller_,
			"Generation",
			g_] := Module[{positiveGeneration, futureEventsToInfinity},
	positiveGeneration = toPositiveStep[
		propertyEvaluate[True, None][obj, caller, "TotalGenerationsCount"], g, caller, "Generation"];
	eventsUpToGeneration = First /@ Position[_ ? (# <= positiveGeneration &)] @ data[$eventGenerations] - 1;
	data[$atomLists][[stateEdgeIndicesAfterEvents[obj, caller, eventsUpToGeneration]]]
]


(* ::Subsubsection:: *)
(*Omit "Generation"*)


propertyEvaluate[True, includeBoundaryEventsPattern][
		WolframModelEvolutionObject[data_ ? evolutionDataQ], caller_, g_Integer] :=
	propertyEvaluate[True, None][WolframModelEvolutionObject[data], caller, "Generation", g]


(* ::Subsection:: *)
(*StatesList*)


propertyEvaluate[True, boundary : includeBoundaryEventsPattern][
		obj : WolframModelEvolutionObject[data_ ? evolutionDataQ],
		caller_,
		"StatesList"] :=
	propertyEvaluate[True, boundary][obj, caller, "Generation", #] & /@
		Range[0, propertyEvaluate[True, boundary][obj, caller, "TotalGenerationsCount"]]


(* ::Subsection:: *)
(*StatesPlotsList*)


propertyEvaluate[True, boundary : includeBoundaryEventsPattern][
		obj : WolframModelEvolutionObject[_ ? evolutionDataQ],
		caller_,
		property : "StatesPlotsList",
		o : OptionsPattern[] /; (Complement[{o}, FilterRules[{o}, Options[WolframModelPlot]]] == {})] :=
	Check[
		Quiet[
			Map[
				Check[
					Check[
						WolframModelPlot[#, o],
						Message[caller::nonHypergraphPlot, property],
						WolframModelPlot::invalidEdges],
					Throw[$Failed]] &,
				propertyEvaluate[True, boundary][obj, caller, "StatesList"]],
			WolframModelPlot::invalidEdges],
		Throw[$Failed]]


(* ::Subsection:: *)
(*EventsStatesPlotsList*)


propertyEvaluate[True, boundary : includeBoundaryEventsPattern][
			obj : WolframModelEvolutionObject[_ ? evolutionDataQ],
			caller_,
			property : "EventsStatesPlotsList",
			o : OptionsPattern[] /; (Complement[{o}, FilterRules[{o}, Options[WolframModelPlot]]] == {})] := Module[{
		events, stateIndices, pictures, destroyedOnlyIndices, createdOnlyIndices, destroyedAndCreatedIndices, allEdges},
	events = propertyEvaluate[True, boundary][obj, caller, "AllEventsList"][[All, 2]];
	stateIndices = FoldList[
		Function[{currentState, newEvent}, Module[{alreadyDeletedExpressions},
			alreadyDeletedExpressions = Complement[newEvent[[1]], currentState];
			If[alreadyDeletedExpressions =!= {},
				makeMessage[caller, "multiwayState", alreadyDeletedExpressions[[1]]];
				Throw[$Failed]];
			Join[DeleteCases[currentState, Alternatives @@ newEvent[[1]]], newEvent[[2]]]]],
		If[MatchQ[boundary, "Initial" | All],
			{},
			propertyEvaluate[True, None][obj, caller, "StateEdgeIndicesAfterEvent", 0]
		],
		events];
	{destroyedOnlyIndices, createdOnlyIndices, destroyedAndCreatedIndices} = Transpose[MapThread[
		{Complement[##], Complement[#2, #1], Intersection[##]} &,
		{Append[events[[All, 1]], {}], Prepend[events[[All, 2]], {}]}]];
	allEdges = propertyEvaluate[True, None][obj, caller, "AllEventsEdgesList"];
	Check[
		Quiet[
			MapThread[
				Check[
					Check[
						WolframModelPlot[
							allEdges[[#]],
							o,
							EdgeStyle -> ReplacePart[
								Table[Automatic, Length[#]],
								Join[
									Thread[Position[#, Alternatives @@ #2][[All, 1]] -> style[$lightTheme][$destroyedEdgeStyle]],
									Thread[Position[#, Alternatives @@ #3][[All, 1]] -> style[$lightTheme][$createdEdgeStyle]],
									Thread[Position[#, Alternatives @@ #4][[All, 1]] ->
										style[$lightTheme][$destroyedAndCreatedEdgeStyle]]]]],
						Message[caller::nonHypergraphPlot, property],
						WolframModelPlot::invalidEdges],
					Throw[$Failed]] &,
				If[MatchQ[boundary, "Initial" | All], Rest /@ # &, # &] @
					If[MatchQ[boundary, All | "Final"], Most /@ # &, # &] @
					{stateIndices, destroyedOnlyIndices, createdOnlyIndices, destroyedAndCreatedIndices}],
			WolframModelPlot::invalidEdges],
		Throw[$Failed]]
]


(* ::Subsection:: *)
(*FinalDistinctElementsCount*)


propertyEvaluate[True, includeBoundaryEventsPattern][
		WolframModelEvolutionObject[data_ ? evolutionDataQ],
		caller_,
		"FinalDistinctElementsCount"] :=
	Length[Union @ Cases[
		propertyEvaluate[True, None][
			WolframModelEvolutionObject[data], caller, "StateAfterEvent", -1],
		_ ? AtomQ,
		All]]


(* ::Subsection:: *)
(*AllEventsDistinctElementsCount*)


propertyEvaluate[True, includeBoundaryEventsPattern][
		WolframModelEvolutionObject[data_ ? evolutionDataQ],
		caller_,
		"AllEventsDistinctElementsCount"] :=
	Length[Union @ Cases[data[$atomLists], _ ? AtomQ, All]]


(* ::Subsection:: *)
(*VertexCountList*)


propertyEvaluate[True, boundary : includeBoundaryEventsPattern][
		obj : WolframModelEvolutionObject[_ ? evolutionDataQ],
		caller_,
		"VertexCountList"] :=
	Length /@ Union /@ Catenate /@ propertyEvaluate[True, boundary][obj, caller, "StatesList"]


(* ::Subsection:: *)
(*EdgeCountList*)


propertyEvaluate[True, boundary : includeBoundaryEventsPattern][
		obj : WolframModelEvolutionObject[_ ? evolutionDataQ],
		caller_,
		"EdgeCountList"] :=
	Length /@ propertyEvaluate[True, boundary][obj, caller, "StatesList"]


(* ::Subsection:: *)
(*FinalEdgeCount*)


propertyEvaluate[True, includeBoundaryEventsPattern][
		WolframModelEvolutionObject[data_ ? evolutionDataQ],
		caller_,
		"FinalEdgeCount"] :=
	Length[propertyEvaluate[True, None][
		WolframModelEvolutionObject[data], caller, "StateAfterEvent", -1]]


(* ::Subsection:: *)
(*AllEventsEdgesCount*)


propertyEvaluate[True, includeBoundaryEventsPattern][
		WolframModelEvolutionObject[data_ ? evolutionDataQ],
		caller_,
		"AllEventsEdgesCount"] :=
	Length[data[$atomLists]]


(* ::Subsection:: *)
(*AllEventsGenerationsList*)


propertyEvaluate[True, includeBoundaryEvents : includeBoundaryEventsPattern][
		evolution : WolframModelEvolutionObject[data_ ? evolutionDataQ],
		caller_,
		"AllEventsGenerationsList"] :=
	If[MatchQ[includeBoundaryEvents, All | "Final"], Append[evolution["TotalGenerationsCount"] + 1], Identity] @
		If[MatchQ[includeBoundaryEvents, None | "Final"], Rest, Identity] @
			data[$eventGenerations]


(* ::Subsection:: *)
(*CausalGraph / LayeredCausalGraph*)


(* ::Text:: *)
(*This produces a causal network for the system. This is a Graph with all events as vertices, and directed edges connecting them if the same event is a creator and a destroyer for the same expression (i.e., if two events are causally related).*)


(* ::Subsubsection:: *)
(*CausalGraph Implementation*)


propertyEvaluate[True, boundary : includeBoundaryEventsPattern][
			obj : WolframModelEvolutionObject[data_ ? evolutionDataQ],
			caller_,
			property : "CausalGraph",
			o : OptionsPattern[]] /;
				(Complement[{o}, FilterRules[{o}, $propertyOptions[property]]] == {}) := Module[{
		eventIndices, events, eventsToExpressions, expressionDestroyers, expressionsToEvents, eventsToEvents, causalEdges,
		allOptionValues},
	eventIndices = If[MatchQ[boundary, "Initial" | All], Prepend[0], Identity] @
		If[MatchQ[boundary, All | "Final"], Append[Infinity], Identity] @
			Range[Length[data[$eventRuleIDs]] - 1];
	events = propertyEvaluate[True, boundary][obj, caller, "AllEventsList"];
	eventsToExpressions = Association[Thread[eventIndices -> events[[All, 2, 2]]]];

	expressionDestroyers = propertyEvaluate[True, boundary][obj, caller, "EdgeDestroyerEventsIndices"];
	expressionsToEvents = Association[Thread[Range[Length[expressionDestroyers]] -> expressionDestroyers]];

	eventsToEvents = Catenate /@ Map[expressionsToEvents, eventsToExpressions, {2}];
	causalEdges = Catenate[Thread /@ Normal[eventsToEvents]];

	allOptionValues = Flatten[Join[{o}, $propertyOptions[property]]];
	Graph[
		eventIndices,
		causalEdges,
		VertexStyle -> Replace[
			OptionValue[allOptionValues, VertexStyle],
			Automatic -> Select[Head[#] =!= Rule || MatchQ[#[[1]], Alternatives @@ eventIndices] &] @ {
				style[$lightTheme][$causalGraphVertexStyle],
				0 -> style[$lightTheme][$causalGraphInitialVertexStyle],
				Infinity -> style[$lightTheme][$causalGraphFinalVertexStyle]}],
		EdgeStyle -> Replace[
			OptionValue[allOptionValues, EdgeStyle], Automatic -> style[$lightTheme][$causalGraphEdgeStyle]],
		Background -> Replace[
			OptionValue[allOptionValues, Background], Automatic -> style[$lightTheme][$causalGraphBackground]],
		allOptionValues]
]


(* ::Subsubsection:: *)
(*LayeredCausalGraph Implementation*)


propertyEvaluate[True, includeBoundaryEvents : includeBoundaryEventsPattern][
		evolution : WolframModelEvolutionObject[data_ ? evolutionDataQ],
		caller_,
		property : "LayeredCausalGraph",
		o : OptionsPattern[]] /;
			(Complement[{o}, FilterRules[{o}, $propertyOptions[property]]] == {}) :=
	Graph[
		propertyEvaluate[True, includeBoundaryEvents][evolution, caller, "CausalGraph", ##] & @@
			FilterRules[FilterRules[{o}, $causalGraphOptions], Except[$newLayeredCausalGraphOptions]],
		GraphLayout -> Replace[
			OptionValue[Flatten[Join[{o}, $propertyOptions[property]]], GraphLayout],
			Automatic -> {
				"LayeredDigraphEmbedding",
				"VertexLayerPosition" ->
					(propertyEvaluate[True, includeBoundaryEvents][evolution, caller, "TotalGenerationsCount"] -
							propertyEvaluate[True, includeBoundaryEvents][evolution, caller, "AllEventsGenerationsList"])}]]


(* ::Subsubsection:: *)
(*TerminationReason Implementation*)


propertyEvaluate[True, includeBoundaryEventsPattern][
		evolution : WolframModelEvolutionObject[data_ ? evolutionDataQ],
		caller_,
		"TerminationReason"] := Replace[data[[Key[$terminationReason]]], Join[Normal[$stepSpecKeys], {
	$fixedPoint -> "FixedPoint",
	$timeConstraint -> "TimeConstraint",
	$Aborted -> "Aborted",
	x : (_ ? MissingQ | Automatic) :> x,
	_ -> Missing["NotAvailable"]
}]]


(* ::Subsubsection:: *)
(*AllEventsRuleIndices*)


propertyEvaluate[True, boundary : includeBoundaryEventsPattern][
		obj : WolframModelEvolutionObject[data_ ? evolutionDataQ],
		caller_,
		"AllEventsRuleIndices"] := propertyEvaluate[True, boundary][obj, caller, "AllEventsList"][[All, 1]]


(* ::Subsubsection:: *)
(*AllEventsList implementation*)


finalEvent[WolframModelEvolutionObject[data_]] :=
	{Infinity, Complement[Catenate[data[$eventOutputs]], Catenate[data[$eventInputs]]] -> {}}


propertyEvaluate[True, boundary : includeBoundaryEventsPattern][
		obj : WolframModelEvolutionObject[data_ ? evolutionDataQ],
		caller_,
		"AllEventsList"] :=
	If[MatchQ[boundary, "Final" | None], Rest, Identity] @
		If[MatchQ[boundary, "Final" | All], Append[finalEvent[obj]], Identity] @
			Transpose[{data[$eventRuleIDs], Thread[data[$eventInputs] -> data[$eventOutputs]]}]


(* ::Subsubsection:: *)
(*EventsStatesList*)


propertyEvaluate[True, boundary : includeBoundaryEventsPattern][
			obj : WolframModelEvolutionObject[_ ? evolutionDataQ],
			caller_,
			"EventsStatesList"] := With[{
		events = propertyEvaluate[True, boundary][obj, caller, "AllEventsList"],
		states = If[MatchQ[boundary, None | "Final"], Rest, # &] @
			If[MatchQ[boundary, All | "Final"], Append[{}], # &] @
			propertyEvaluate[True, boundary][obj, caller, "AllEventsStatesEdgeIndicesList"]},
	Transpose[{events, states}]
]


(* ::Subsubsection:: *)
(*EdgeCreatorEventIndices*)


propertyEvaluate[True, boundary : includeBoundaryEventsPattern][
		obj : WolframModelEvolutionObject[data_ ? evolutionDataQ],
		caller_,
		"EdgeCreatorEventIndices"] := Module[{events, eventInputs},
	events = propertyEvaluate[True, "Initial"][obj, caller, "AllEventsList"];
	eventOutputs = events[[All, 2, 2]];
	Sort[Catenate[Thread /@ Thread[eventOutputs -> Range[Length[events]] - 1]]][[All, 2]]
]


(* ::Subsubsection:: *)
(*EdgeDestroyerEventsIndices*)


propertyEvaluate[True, boundary : includeBoundaryEventsPattern][
		obj : WolframModelEvolutionObject[data_ ? evolutionDataQ],
		caller_,
		"EdgeDestroyerEventsIndices"] := Module[{events, eventInputs, edgeToDestroyerRules, resultWithInfinities},
	events = propertyEvaluate[True, "Final"][obj, caller, "AllEventsList"];
	eventInputs = events[[All, 2, 1]];
	edgeToDestroyerRules = Sort[Catenate[Thread /@ Thread[eventInputs -> Append[Range[Length[events] - 1], Infinity]]]];
	resultWithInfinities = Map[Last, Values[GroupBy[edgeToDestroyerRules, First]], {2}];
	If[MatchQ[boundary, None | "Initial"], resultWithInfinities /. Infinity -> Nothing, resultWithInfinities]
]


(* ::Subsubsection:: *)
(*EdgeDestroyerEventIndices*)


eventListToSingleEvent[caller_, {event_}, _] := event

eventListToSingleEvent[caller_, {_, __}, expression_] := (
	makeMessage[caller, "multiwayState", expression];
	Throw[$Failed]
)


propertyEvaluate[True, boundary : includeBoundaryEventsPattern][
		obj : WolframModelEvolutionObject[data_ ? evolutionDataQ],
		caller_,
		"EdgeDestroyerEventIndices"] := Module[{eventLists},
	eventLists = propertyEvaluate[True, "Final"][obj, caller, "EdgeDestroyerEventsIndices"];
	MapIndexed[eventListToSingleEvent[caller, #, #2[[1]]] &, eventLists]
]


(* ::Subsubsection:: *)
(*EdgeGenerationsList*)


propertyEvaluate[True, includeBoundaryEventsPattern][
		obj : WolframModelEvolutionObject[_ ? evolutionDataQ],
		caller_,
		"EdgeGenerationsList"] := Module[{},
	propertyEvaluate[True, "Initial"][obj, caller, "EventGenerations"][[
		propertyEvaluate[True, "Initial"][obj, caller, "EdgeCreatorEventIndices"] + 1]]
]


(* ::Subsection:: *)
(*Public properties call*)


$masterOptions = {
	"IncludePartialGenerations" -> True,
	"IncludeBoundaryEvents" -> None
};


WolframModelEvolutionObject[
		data_ ? evolutionDataQ][
		property__ ? (Not[MatchQ[#, OptionsPattern[]]] &),
		opts : OptionsPattern[]] := Module[{prunedObject, result},
	result = Catch[
		(propertyEvaluate @@
				(OptionValue[Join[{opts}, $masterOptions], #] & /@ {"IncludePartialGenerations", "IncludeBoundaryEvents"}))[
			WolframModelEvolutionObject[data],
			WolframModelEvolutionObject,
			property,
			##] & @@ Flatten[FilterRules[{opts}, Except[$masterOptions]]]];
	result /; result =!= $Failed
]


(* ::Section:: *)
(*Argument Checks*)


(* ::Text:: *)
(*Argument Checks should be evaluated after Implementation, otherwise ::corrupt messages will be created while assigning SubValues.*)


(* ::Subsection:: *)
(*Argument count*)


WolframModelEvolutionObject[args___] := 0 /;
	!Developer`CheckArgumentCount[WolframModelEvolutionObject[args], 1, 1] && False


WolframModelEvolutionObject[data_][opts : OptionsPattern[]] := 0 /;
  Message[WolframModelEvolutionObject::argm, Defer[WolframModelEvolutionObject[data][opts]], 0, 1]


(* ::Subsection:: *)
(*Association has correct fields*)


$currentVersion = 2;


evolutionDataQ[data_Association] := evolutionDataQ[Lookup[data, $version, 1], data]


evolutionDataQ[1, data_Association] :=
	Sort[Keys[data]] === Sort[{
		$creatorEvents, $destroyerEvents, $generations, $atomLists, $rules, $maxCompleteGeneration, $terminationReason,
		$eventRuleIDs}]


evolutionDataQ[2, data_Association] :=
	Keys[data] === {
		$version, $rules, $maxCompleteGeneration, $terminationReason, $atomLists, $eventRuleIDs, $eventInputs,
		$eventOutputs, $eventGenerations}


evolutionDataQ[___] := False


WolframModelEvolutionObject::migrationInputOrdering =
	"Migrating the evolution object from version 1. The ordering of event inputs may be incorrect.";


migrateEvolutionObjectData[data_, 1, 2] := Module[{eventsToInputs, eventsToOutputs, eventInputs, eventOutputs},
	Message[WolframModelEvolutionObject::migrationInputOrdering];
	{eventsToInputs, eventsToOutputs} =
		GroupBy[Thread[data[#] -> Range[Length[data[#]]]], First][[All, All, 2]] & /@ {$destroyerEvents, $creatorEvents};
	{eventInputs, eventOutputs} = Function[{eventsToExpressions},
		Lookup[eventsToExpressions, #, {}] & /@ Range[0, Length[data[$eventRuleIDs]]]] /@ {eventsToInputs, eventsToOutputs};
	<|$version -> 2,
		$rules -> data[$rules],
		$maxCompleteGeneration -> data[$maxCompleteGeneration],
		$terminationReason -> data[$terminationReason],
		$atomLists -> data[$atomLists],
		$eventRuleIDs -> Join[{0}, data[$eventRuleIDs]],
		$eventInputs -> eventInputs,
		$eventOutputs -> eventOutputs,
		$eventGenerations -> (Max[Append[#, -1]] + 1 &) /@ Map[data[$generations][[#]] &, eventInputs, {2}]|>
]


WolframModelEvolutionObject[data_] /;
		Lookup[data, $version, 1] < $currentVersion && evolutionDataQ[data] :=
	WolframModelEvolutionObject[migrateEvolutionObjectData[data, Lookup[data, $version, 1], 2]]


WolframModelEvolutionObject::future =
	"WolframModelEvolutionObject is produced by a later version of SetReplace. " <>
	"Evaluate PacletInstall[\"SetReplace\"], or check " <>
	"https://github.com/maxitg/SetReplace/blob/master/README.md#getting-started to install manually.";


WolframModelEvolutionObject[data_] /; data[$version] > $currentVersion := 0 /;
	Message[WolframModelEvolutionObject::future]


WolframModelEvolutionObject::corrupt =
	"WolframModelEvolutionObject does not have a correct format. " <>
	"Use WolframModel for construction.";


WolframModelEvolutionObject[data_] /;
		Lookup[data, $version, 1] <= $currentVersion && !evolutionDataQ[data] := 0 /;
	Message[WolframModelEvolutionObject::corrupt]
